{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Alyona's personal blog","text":"<p>Hi! I'd like to share some things I learned doing registrtion and segmentation of large 3D biological images in the past 4 years</p>"},{"location":"train-eval-disparity/","title":"Is <code>BatchNorm</code> a good choice for my problem?","text":"<p>Follow-up tutorial for </p>"},{"location":"train-eval-disparity/#tiling-artifacts-and-trade-offs-of-feature-normalization-in-the-segmentation-of-large-biological-images-at-iccv-2025","title":"Tiling artifacts and trade-offs of feature normalization in the segmentation of large biological images at ICCV 2025","text":""},{"location":"train-eval-disparity/#my-model-doesnt-do-the-thing","title":"My model doesn't do the thing \u02d9\u25e0\u02d9","text":"<p>During training the loss confidently goes down and the model makes correct or at least reasonable predictions. Sometimes it is even correct in the cases where the ground truth label is obviously wrong! Awesome. However, in the evaluation the predictions don't look so good. Even when the training and evaluation data come from the same source and have no perceptual difference.</p> <p>The common knowledge explanation is overfitting. Overfitting means that there is a substantial difference between training and evaluation data so the statistical distribution learned by the model based on trainig data doesn't describe what's going on in the evaluation data, leading to prediction errors. There are two widely known remedies for overfitting: adding more training data and augmentations.</p> <p>Adding more training data is pretty straightforward: we check what kind of errors the model made on test data, annotate a few hard cases and add these annotations to the training data. Now training data more faithfully reflects the target distribution and predictions should get better. However it's not always possible to annotate more data, so instead we can try to make training data look a bit more similar to the evaluation data by applying some random transformations. For example, if we know that the evaluation data contains some images with less contrast or with some defocused areas, we can apply contrast adjustment or gaussian blur to some images in the training dataset. Now the model \"has seen\" these examples and will not make so many mistakes during evaluation.</p> <p>Makes sense, right? Any machine learning course teaches this within the first 2-3 lectures.</p> <p>However, the longer I worked on biological image segmentation, the less it seemed that overfitting is the answer. I made the following observations:</p> <ul> <li>Often the errors made by pretrained models made no sense. It wasn't like \"my images are a little brighter than the training set on average so the model predicts too much foreground\". It was more of \"predict foreground more or less correctly and then also randomly find something in the background\" or \"make more or less correct predictions in half the image and then completely fail in the other exactly same-looking half\". </li> <li>Augmentations made barely any difference in training results. Sure, if I went way too hard on intensity augmentations, I could make the training diverge and fail completely, but the reasonable rotation, gaussian noise and slight contrast adjustments never did anything, whether I just put in the strongest augmentations I could or spent hours inspecting raw data and adjusting augmentations to match the natural variability of the data. </li> <li>(gasp) Adding more ground truth didn't always make results better.</li> </ul> <p>Turns out that there's another, normally overlooked, source of failure: train/evaluation disparity. In this tutorial I will explain what it is, show why it's so ubiquitous in bioimage analysis and suggest some ways to avoid it in your particular pipeline. </p> <p>In this tutorial we will explore the effect of batch size and dataset diversity using cell boundary segmentation in electron microscopy with 3D U-Net as an example. Here we will use a modified U-Net implementation from Monai, however, the same analysis can be done for any dataset and any CNN-based pipeline.</p>"},{"location":"train-eval-disparity/#sliding-window-inference-and-patch-sampling-in-training","title":"Sliding window inference and patch sampling in training","text":"<p>Biological images, especially in the case of volumetric imaging, are large. Electron microscopy volumes for connectomics or light sheet microscopy volumes can reach the scale of multiple terabytes. It is routine to work with 10-100 GB images of \\(\u223c1000^3\\) pixels, which exceed GPU memory.</p> <p>During training random patches are sampled from the annotated images and combined into a batch. During inference/evaluation, the image is split into a grid of tiles which are predicted independently and then stitched back to form the full prediction. Here I refer both to 2D and 3D image patches as tiles. In this setup the size of the tiles is limited from above by GPU memory and from below by the receptive field of the network. Typical tile size is around 96x96x96 - 256x256x256 pixels and the training batch size is 2-3 tiles per batch. During inference it is not necessary to store gradients, therefore either tile size or batch size can be larger.</p>"},{"location":"train-eval-disparity/#diversity-of-biological-datasets","title":"Diversity of biological datasets","text":"<p>Another important feature of biological images is extreme class disbalance. Within one image whole areas can contain no foreground objects. Let's inspect one electron microscopy volume as an example.</p> <pre><code>from bio_monai.data import load_data_config\nfrom no_tiling.data import config_to_dataset\nimport yaml\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import colors\nimport matplotlib.patches as mpatches\n</code></pre> <pre><code>config_path = \"experiments/em_organoids/setup_01.yaml\"\ndata_config_path = \"experiments/em_organoids/data_config_organoids_full.json\"\n\nwith open(config_path, \"r\") as yamlfile:\n    config = yaml.load(yamlfile, Loader=yaml.FullLoader)\n\ndata_config = load_data_config(data_config_path)\n\ncols = {\"fg\": \"#66c2a5\", \"bg\": \"#8da0cb\", \"boundaries\": \"#fc8d62\", \"extra\": \"#e78ac3\"}\nchannels = {\"fg\": 0, \"bg\": 3, \"boundaries\": 1, \"extra\": 2}\nfull_names = {\"fg\": \"foreground\", \"bg\": \"background\", \"boundaries\": \"boundaries\", \"extra\": \"extracellular\"}\n</code></pre> <pre><code>Read data config\nRead successful\n</code></pre> <pre><code>ds = config_to_dataset(config[\"train\"][\"dataset\"], data_config[\"full_data\"])\n</code></pre> <pre><code>Loading dataset: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [03:39&lt;00:00, 219.93s/it]\n</code></pre> <pre><code>data = ds[0][\"image\"].numpy()[0]\nlabel = ds[0][\"label\"].numpy().astype(np.uint16)\n</code></pre> <pre><code>xy_slice_roi = np.s_[500, :, :]\nxz_slice_roi = np.s_[:, 750, :]\nplt.figure(figsize=(20, 20))\n\nf, ax = plt.subplots(2, 2, sharey=True, figsize=(20, 20))\n\nax[0, 0].imshow(data[xy_slice_roi], cmap=\"Greys_r\")\nax[0, 0].set_xlabel(\"X\")\nax[0, 0].set_ylabel(\"Y\")\n\nax[1, 0].imshow(data[xz_slice_roi], cmap=\"Greys_r\")\nax[1, 0].set_xlabel(\"X\")\nax[1, 0].set_ylabel(\"Z\")\n\nlegend_patches = []\nfor name, chan in channels.items():\n    cmap = colors.ListedColormap(['white', cols[name]])\n    ax[0, 1].imshow(label[chan][xy_slice_roi], label=name, cmap=cmap, alpha=(label[chan][xy_slice_roi] &gt; 0).astype(float))\n    legend_patches.append(mpatches.Patch(color=cols[name], label=full_names[name]))\n\nax[1, 1].legend(handles=legend_patches, fontsize=\"large\", ncol=4)\nax[0, 1].set_xlabel(\"X\")\nax[0, 1].set_ylabel(\"Y\")\n\nlegend_patches = []\nfor name, chan in channels.items():\n    cmap = colors.ListedColormap(['white', cols[name]])\n    ax[1, 1].imshow(label[chan][xz_slice_roi], label=name, cmap=cmap, alpha=(label[chan][xz_slice_roi] &gt; 0).astype(float))\n    legend_patches.append(mpatches.Patch(color=cols[name], label=full_names[name]))\n\n\nax[0, 1].legend(handles=legend_patches, fontsize=\"large\", ncol=4)\nax[1, 1].set_xlabel(\"X\")\nax[1, 1].set_ylabel(\"Z\")\n\n\nplt.tight_layout()\n</code></pre> <pre><code>&lt;Figure size 2000x2000 with 0 Axes&gt;\n</code></pre>  <p>This is a FIB-SEM volume of a tissue and the task was to segment individual cells out. For that we need a network to perform semantic segmentation of 4 classes:</p> <ul> <li>Foreground: areas inside the cells</li> <li>Background: black area where there is no electron microscopy signal</li> <li>Boundaries: interfaces between cells</li> <li>Extracellular matrix: free space between cells</li> </ul> <p>Why this dataset? It's not really a benchmark dataset and it's legit to ask why do we care about segmenting cell boundaries in some weird organoids. In my opinion it neatly demonstrates the difficulties bioimage analysts face in every project:</p> <ul> <li>The volume is large (\\(1349 \\times 1505 \\times 1646\\) pixels) but not crazy large (fully fits into RAM on a decent machine but definitely not into GPU memory)</li> <li>The imaging method (FIB-SEM) is well-established but the sample preparation for this particular sample was quite special, so the visual appearance is unique</li> <li>Even if we imagine taking a model for cell boundaries trained on some other electron microscopy data (I'm not aware of the existance of any dataset that is even somewhat similar), it doesn't solve the problem of segmenting extracellular matrix</li> <li>Seems like <code>image == 0</code> should solve segmenting background class, but there are the lipid droplets which also have 0 signal. In principle we could apply an heuristic for segmenting background, like taking the largest connected component, but it is not transferable to other datasets (not shown here). One of the downstream tasks is counting lipid droplets per cell, so ignoring them is not an option as well  </li> <li>Cell boundaries can be super thin - down to 1 pixel wide - or very thick in different parts of the dataset, so it's not possible to downsample it further</li> <li>The dataset is quite unbalanced but the classes are distributed throughout the volume so it's not possible to pick just one foreground area and train on it</li> </ul> <pre><code>plt.figure()\nfor name, chan in channels.items():\n    plt.bar(chan, label[chan].sum() / label[chan].size, tick_label=full_names[name], color=cols[name])\n    print(name, label[chan].sum() / label[chan].size)\nnames = channels.keys()\nplt.xticks([channels[name] for name in names], [full_names[name] for name in names]);\nplt.ylabel(\"Proportion of the class is full dataset\")\n</code></pre> <pre><code>fg 0.564123369077732\nbg 0.2950981764296163\nboundaries 0.09271733890749893\nextra 0.04806111558515283\n\n\n\n\n\nText(0, 0.5, 'Proportion of the class is full dataset')\n</code></pre>  <p>As we can see, boundaries class takes up \\(9%\\) of the volume. Let's sample the training samples of size \\(128 \\times 128 \\times 128\\) from the dataset and check the distribution of the boundaries class.</p> <pre><code>from monai.data import GridPatchDataset, DataLoader, PatchIterd\npatch_iter = PatchIterd(keys=[\"image\", \"label\"], patch_size=(128, 128, 128), start_pos=(0, 0, 0))\ngrid_dataset = GridPatchDataset(data=ds, patch_iter=patch_iter)\nfrom tqdm import tqdm\nclass_distribution = {\"fg\": [], \"boundaries\": [], \"extra\": [], \"bg\": []}\n\nfor item in tqdm(DataLoader(grid_dataset, batch_size=1, num_workers=8)):\n    item = item[0]\n    img = item[\"image\"].numpy()[0]\n    lbl = item[\"label\"].numpy()[0].astype(np.uint16)\n    class_distribution[\"fg\"].append(lbl[0].sum() / lbl[0].size)\n    class_distribution[\"boundaries\"].append(lbl[1].sum() / lbl[1].size)\n    class_distribution[\"extra\"].append(lbl[2].sum() / lbl[2].size)\n    class_distribution[\"bg\"].append(lbl[3].sum() / lbl[3].size)\n</code></pre> <pre><code>1716it [01:03, 26.90it/s]\n</code></pre> <pre><code>plt.hist(class_distribution[\"boundaries\"], bins=100, color=cols[\"boundaries\"])\nplt.ylabel(\"Number of samples\")\nplt.xlabel(\"Proportion of boundary class in training patch\")\n</code></pre> <pre><code>Text(0.5, 0, 'Proportion of boundary class in training patch')\n</code></pre>  <p>Most of the samples have no boundary class and the rest of the samples are far from the dataset-wide \\(10%\\). Sampling randomly, we would need batches of approximately N samples to correctly estimate the boundary class proportion in most samples.</p> <pre><code>import seaborn as sns\nimport pandas as pd\n\nsampled_proportions = pd.DataFrame()\nfor batch_size in (1, 2, 4, 8, 16, 32, 64, 128, 256):\n    sampled_proportions[batch_size] = [np.sum(np.random.choice(class_distribution[\"boundaries\"], replace=True, size=batch_size)) / batch_size for _ in range(1000)]\n</code></pre> <pre><code>plt.figure(figsize=(12, 4))\nsns.stripplot(sampled_proportions, jitter=0.4, alpha=0.2)\nplt.xlabel(\"batch size\")\nplt.ylabel(\"Proportion of boundaries class in each batch\")\n</code></pre> <pre><code>Text(0, 0.5, 'Proportion of boundaries class in each batch')\n</code></pre>  <p>So, to stay reasonably close to volume-wise \\(9%\\) we would need a batch size of \\(32\\) or more, which is impossible with current GPU memory. Of course, there can be variation within the samples of one class too but this little experiment gives us an idea of how diverse the data is and how bad we are at sampling it.  </p>"},{"location":"train-eval-disparity/#batchnorm-refresher","title":"<code>BatchNorm</code> refresher","text":"<p>Neural networks consist of a series of filters with normalization and nonlinearity layers in between. Feature normalization helps to make convergence faster and more stable with respect to training parameters. In most cases it's probably possible to train a network with no normalization layers at all - however, the search for optimal learning rate schedule and other parameters might require much more effort.</p> <p>The general formula for the normalization operation with input \\(x\\), output \\(y\\) is:</p> <p>$$ y = \\frac{x-\\mu}{\\sqrt{\\sigma^2 + \\epsilon}}, $$ where \\(\\mu\\) and \\(\\sigma\\) are normalization parameters and \\(\\epsilon\\) is a small constant used for numerical stability. Parameters \\(\\mu\\) and \\(\\sigma\\) can be estimated directly from the input \\(\\mu = \\mathrm{E}[x]\\) and \\(\\sigma^2 = \\mathrm{Var}[x]\\), where average can be taken either over each sample independently or over the whole batch. Alternatively, global normalization parameters independent of the current input can be used. A common strategy is to estimate the parameters as a running average over multiple samples: \\(p_{new} = (1 - momentum) \\times p_{old} + momentum \\times p_{t}\\). The update speed is determined by the \\(momentum\\), set to \\(0.1\\) by default. </p> <p>During training \\(BatchNorm\\) uses statistics of the current batch and collects a running average. During inference it uses saved running average. Although running mean and variance are not learned in a sense that there's no gradient descent with respect to these parameters, they are estimated from the training data.</p> <p>An important assumption here is that the feature statistics of training batches remain stable and correspond to dataset-wide statistics. Let's look at what happens when it's not the case.</p>"},{"location":"train-eval-disparity/#real-mean-and-variance-of-features-vs-batch-statistics","title":"Real mean and variance of features vs batch statistics","text":"<p>I trained a 3D U-Net to segment the electron microscopy volume introduced earlier. This model uses \\(BatchNorm\\):</p> <pre><code>from monai.utils import set_determinism\nfrom monai.data import DataLoader, PatchDataset\nfrom monai.transforms import RandSpatialCropSamplesd\n\nimport torch\nfrom no_tiling.models import load_model\n\nfrom torchvision.models.feature_extraction import get_graph_node_names, create_feature_extractor\n\n</code></pre> <pre><code>model_path = \"data/experiments/organoids_boundaries/setup_01/model_epoch_0025.pth\"\n\n# Monai settings\nset_determinism(seed=0)\n\n# Set device\nif torch.cuda.is_available():\n    print(\"GPU is available\")\n    device = torch.device(6)\nelse:\n    print(\"GPU is not available\")\n    device = torch.device(\"cpu\")\n\n# Load model    \nmodel = load_model(model_path).to(device)\nmodel.eval()\nprint(model)\n</code></pre> <pre><code>GPU is available\nBasicUNet features: (32, 64, 128, 32).\nScaling factors: [[2, 2, 2], [2, 2, 2]]\nUNet(\n  (conv_0): TwoConv(\n    (conv_0): Convolution(\n      (conv): Conv3d(1, 32, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n      (adn): ADN(\n        (N): InstanceNorm3d(32, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n        (D): Dropout3d(p=0.0, inplace=False)\n        (A): LeakyReLU(negative_slope=0.1, inplace=True)\n      )\n    )\n    (conv_1): Convolution(\n      (conv): Conv3d(32, 32, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n      (adn): ADN(\n        (N): InstanceNorm3d(32, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n        (D): Dropout3d(p=0.0, inplace=False)\n        (A): LeakyReLU(negative_slope=0.1, inplace=True)\n      )\n    )\n  )\n  (downs): ModuleList(\n    (0): Down(\n      (max_pooling): MaxPool3d(kernel_size=[2, 2, 2], stride=[2, 2, 2], padding=0, dilation=1, ceil_mode=False)\n      (convs): TwoConv(\n        (conv_0): Convolution(\n          (conv): Conv3d(32, 64, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n          (adn): ADN(\n            (N): InstanceNorm3d(64, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n            (D): Dropout3d(p=0.0, inplace=False)\n            (A): LeakyReLU(negative_slope=0.1, inplace=True)\n          )\n        )\n        (conv_1): Convolution(\n          (conv): Conv3d(64, 64, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n          (adn): ADN(\n            (N): InstanceNorm3d(64, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n            (D): Dropout3d(p=0.0, inplace=False)\n            (A): LeakyReLU(negative_slope=0.1, inplace=True)\n          )\n        )\n      )\n    )\n    (1): Down(\n      (max_pooling): MaxPool3d(kernel_size=[2, 2, 2], stride=[2, 2, 2], padding=0, dilation=1, ceil_mode=False)\n      (convs): TwoConv(\n        (conv_0): Convolution(\n          (conv): Conv3d(64, 128, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n          (adn): ADN(\n            (N): InstanceNorm3d(128, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n            (D): Dropout3d(p=0.0, inplace=False)\n            (A): LeakyReLU(negative_slope=0.1, inplace=True)\n          )\n        )\n        (conv_1): Convolution(\n          (conv): Conv3d(128, 128, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n          (adn): ADN(\n            (N): InstanceNorm3d(128, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n            (D): Dropout3d(p=0.0, inplace=False)\n            (A): LeakyReLU(negative_slope=0.1, inplace=True)\n          )\n        )\n      )\n    )\n  )\n  (upcats): ModuleList(\n    (0): UpCat(\n      (upsample): UpSample(\n        (deconv): ConvTranspose3d(128, 64, kernel_size=(2, 2, 2), stride=(2, 2, 2))\n      )\n      (convs): TwoConv(\n        (conv_0): Convolution(\n          (conv): Conv3d(128, 64, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n          (adn): ADN(\n            (N): InstanceNorm3d(64, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n            (D): Dropout3d(p=0.0, inplace=False)\n            (A): LeakyReLU(negative_slope=0.1, inplace=True)\n          )\n        )\n        (conv_1): Convolution(\n          (conv): Conv3d(64, 64, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n          (adn): ADN(\n            (N): InstanceNorm3d(64, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n            (D): Dropout3d(p=0.0, inplace=False)\n            (A): LeakyReLU(negative_slope=0.1, inplace=True)\n          )\n        )\n      )\n    )\n    (1): UpCat(\n      (upsample): UpSample(\n        (deconv): ConvTranspose3d(64, 64, kernel_size=(2, 2, 2), stride=(2, 2, 2))\n      )\n      (convs): TwoConv(\n        (conv_0): Convolution(\n          (conv): Conv3d(96, 32, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n          (adn): ADN(\n            (N): InstanceNorm3d(32, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n            (D): Dropout3d(p=0.0, inplace=False)\n            (A): LeakyReLU(negative_slope=0.1, inplace=True)\n          )\n        )\n        (conv_1): Convolution(\n          (conv): Conv3d(32, 32, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n          (adn): ADN(\n            (N): InstanceNorm3d(32, eps=1e-05, momentum=0.01, affine=False, track_running_stats=True)\n            (D): Dropout3d(p=0.0, inplace=False)\n            (A): LeakyReLU(negative_slope=0.1, inplace=True)\n          )\n        )\n      )\n    )\n  )\n  (final_conv): Conv3d(32, 4, kernel_size=(1, 1, 1), stride=(1, 1, 1))\n  (final_activation): Softmax(dim=1)\n)\n</code></pre> <p>The network starts with the convolution <code>conv_0</code> followed by a normalization layer and nonlinearity. In principle normalization layers are supposed to standardize the features: center the distribution around zero and force unit variance. But does it actually happen when the batch size is small?</p> <p>Let's extract the outputs of the very first convolution and look at their statistics.</p> <pre><code>nodes, _ = get_graph_node_names(model)\nprint(nodes)\n\nfeature_extractor = create_feature_extractor(model, return_nodes=['conv_0.conv_0.conv'])\n\n</code></pre> <pre><code>['x', 'conv_0.conv_0.conv', 'conv_0.conv_0.adn.N', 'conv_0.conv_0.adn.D', 'conv_0.conv_0.adn.A', 'conv_0.conv_1.conv', 'conv_0.conv_1.adn.N', 'conv_0.conv_1.adn.D', 'conv_0.conv_1.adn.A', 'downs.0.max_pooling', 'downs.0.convs.conv_0.conv', 'downs.0.convs.conv_0.adn.N', 'downs.0.convs.conv_0.adn.D', 'downs.0.convs.conv_0.adn.A', 'downs.0.convs.conv_1.conv', 'downs.0.convs.conv_1.adn.N', 'downs.0.convs.conv_1.adn.D', 'downs.0.convs.conv_1.adn.A', 'downs.1.max_pooling', 'downs.1.convs.conv_0.conv', 'downs.1.convs.conv_0.adn.N', 'downs.1.convs.conv_0.adn.D', 'downs.1.convs.conv_0.adn.A', 'downs.1.convs.conv_1.conv', 'downs.1.convs.conv_1.adn.N', 'downs.1.convs.conv_1.adn.D', 'downs.1.convs.conv_1.adn.A', 'upcats.0.upsample.deconv', 'upcats.0.convs.conv_0.conv', 'upcats.0.convs.conv_0.adn.N', 'upcats.0.convs.conv_0.adn.D', 'upcats.0.convs.conv_0.adn.A', 'upcats.0.convs.conv_1.conv', 'upcats.0.convs.conv_1.adn.N', 'upcats.0.convs.conv_1.adn.D', 'upcats.0.convs.conv_1.adn.A', 'upcats.1.upsample.deconv', 'upcats.1.convs.conv_0.conv', 'upcats.1.convs.conv_0.adn.N', 'upcats.1.convs.conv_0.adn.D', 'upcats.1.convs.conv_0.adn.A', 'upcats.1.convs.conv_1.conv', 'upcats.1.convs.conv_1.adn.N', 'upcats.1.convs.conv_1.adn.D', 'upcats.1.convs.conv_1.adn.A', 'final_conv', 'final_activation']\n</code></pre> <pre><code>running_mean = model.conv_0.conv_0.adn.N.running_mean.cpu().numpy()\nrunning_var = model.conv_0.conv_0.adn.N.running_var.cpu().numpy()\n</code></pre> <pre><code>n_samples = 100\n\ntrain_sampler = RandSpatialCropSamplesd(keys=[\"image\", \"label\"], roi_size=[128, 128, 128], num_samples=n_samples,\n                            random_center=True, random_size=False)\n\ntrain_patch_dataset = PatchDataset(data=ds,\n            patch_func=train_sampler,\n            samples_per_image=n_samples)\n\ntrain_loader = DataLoader(train_patch_dataset, batch_size=1)\n</code></pre> <pre><code>feature_extractor = create_feature_extractor(\nmodel, return_nodes=['conv_0.conv_0.conv'])\n\nconv_features = []\n\nfor tile in train_loader:\n    # Plot input\n    # print(tile[\"image\"])\n    # plt.imshow(tile[\"image\"][0, 0, 32, ...])\n    plt.show()\n    out = feature_extractor(tile[\"image\"].to(device))\n    conv_feat = out['conv_0.conv_0.conv'].detach().to(\"cpu\")\n    # Plot feature maps\n    # plt.imshow(conv_feat[0, 8, 32, ...])\n    # plt.show()\n    conv_features.append(conv_feat[0, :, ...])\n\ntile_mean = np.array([np.mean(feat, axis=(1, 2, 3)) for feat in conv_features])\ntile_var = np.array([np.var(feat, axis=(1, 2, 3)) for feat in conv_features])\n</code></pre> <pre><code>f, axes = plt.subplots(8, 4,  sharex=True, figsize=(15, 20))\n\nfor feat_idx, ax in enumerate(axes.flat):\n\n    ax.hlines(running_mean[feat_idx], xmin=0, xmax=n_samples, color=\"red\", label=\"running_mean\")\n    # plt.hlines(tile_mean[:, 0].mean(), xmin=0, xmax=100, color=\"green\")\n    ax.fill_between(range(n_samples), [running_mean[feat_idx] + running_var[feat_idx]] * n_samples,  [running_mean[feat_idx] - running_var[feat_idx]] * n_samples, color=\"pink\", alpha=0.8, label=\"running_var\")\n    ax.scatter(range(n_samples), tile_mean[:, feat_idx], marker=\".\", label=\"patch mean\")\n\n    ax.set_title(f\"feature map {feat_idx}\")\n\naxes[0, 0].legend()\nfor idx in range(4):\n    axes[7, idx].set_xlabel(\"sampled patches\")\nfor idx in range(8):\n    axes[idx, 0].set_ylabel(\"mean feature value\")\n\n\nplt.show()\n</code></pre>  <p>Here each of the 32 small panels corresponds to one feature map of the very first convolution layer. This convolution is applied directly to the input data and its output does not depend on the normalizations within the network. We just run the network on 100 random patches from the training subvolume using exactly the same data loader as was used while training the model. </p> <ul> <li>Each blue dot is a mean of the particular feature over one patch - this value is used by <code>BatchNorm</code> for normalization during training</li> <li>Red line is the <code>running_mean</code> remembered by <code>BatchNorm</code> during training - this value is used for normalization during inference</li> <li>Pink area is <code>running_var</code> remembered by <code>BatchNorm</code> during training</li> </ul> <p>With batch size 1 during training each patch gets nicely standardized because <code>BatchNorm</code> uses statistics of the input. During evaluation <code>running_mean</code> and <code>running_var</code> are used - and they are just wrong for most of the patches! </p> <p>But maybe it's not that bad? Let's check how this affects the predictions.</p>"},{"location":"train-eval-disparity/#traineval-disparity","title":"Train/eval disparity","text":"<p>Usually people assume that the network performs roughly the same in <code>train</code> and <code>eval</code> mode. But we have just seen that the feature maps are normalized completely differently. Let's try to run the network on the same patch in train and eval mode and see if there's a difference.</p> <pre><code>n_samples = 5\n\ntrain_sampler = RandSpatialCropSamplesd(keys=[\"image\", \"label\"], roi_size=[128, 128, 128], num_samples=n_samples,\n                            random_center=True, random_size=False)\n\ntrain_patch_dataset = PatchDataset(data=ds,\n            patch_func=train_sampler,\n            samples_per_image=n_samples)\n\ntrain_loader = DataLoader(train_patch_dataset, batch_size=1)\n</code></pre> <pre><code>for tile in train_loader:\n\n    # Only show examples with boundary class in the ground truth\n    if tile[\"label\"][0, 1, 32, ...].sum() &gt; 0:\n\n        f, axes = plt.subplots(1, 4,  sharex=True, figsize=(20, 4))\n\n        axes[0].imshow(tile[\"image\"][0, 0, 32, ...], cmap=\"Greys_r\")\n        axes[0].set_title(\"Input image\")\n        axes[1].imshow(tile[\"label\"][0, 1, 32, ...], cmap=\"Greys_r\")\n        axes[1].set_title(\"Boundaries ground truth\")\n\n        model.eval()\n        out_eval = model(tile[\"image\"].to(device)).detach().to(\"cpu\")\n\n        axes[2].imshow(out_eval[0, 1, 32, ...], cmap=\"Greys_r\")\n        axes[2].set_title(\"Boundaries prediction model.eval()\")\n\n        model.train()\n        out_train = model(tile[\"image\"].to(device)).detach().to(\"cpu\")\n\n        axes[3].imshow(out_train[0, 1, 32, ...], cmap=\"Greys_r\")\n        axes[3].set_title(\"Boundaries prediction model.train()\")\n\n        plt.show()\n</code></pre>      <p>Predictions in <code>train</code> and <code>eval</code> modes are actually very different and the predictions in training mode are much closer to the ground truth - which makes sense, because the network was trained with normalization layers always using the statistics of the input batch. In this case <code>batch_size=1</code> so the plots where we looked at the real feature mean and remembered value accurately show what happened. </p> <p>The training looked all normal with both train and eval loss going down. There was a gap between train and eval metric (Mean Dice 0.75 for train and 0.65 for eval) but it could in theory result from the overfitting. </p>"},{"location":"train-eval-disparity/#traineval-disparity-metric","title":"Train/eval disparity metric","text":"<p>Of course, the difference is random patch to patch so it's better to run sliding window inference for the full dataset in both modes and compare the results. </p> <p>To measure the difference quantitatively, I introduced the following metric:  $$ train/eval\\ disparity = 1 - Dice(P_{train}, P_{eval}),  $$  where \\(P_{train}\\) is the prediction done with  <code>model.train()</code> and \\(P_{eval}\\) - with <code>model.eval()</code>. If the predictions match perfectly, mismatch is 0 and if they are the exact opposites of each other, it's 1.</p> <p>For our example dataset, train/eval mismatch for the boundary channel is 0.48, which is actually surprisingly strong difference. At this point the loss calculated during training is basically not representative of the real model performance all due to batch statistics instability. </p>"},{"location":"train-eval-disparity/#practical-tips","title":"Practical tips","text":""},{"location":"train-eval-disparity/#how-to-check-if-statistics-instability-ruins-my-networks-performance","title":"How to check if statistics instability ruins my network's performance?","text":"<ul> <li>Run your prediction pipeline with <code>model.eval()</code> and <code>model.train()</code> on the same data and compare the results </li> <li>Compare results visually or quantify using train/eval disparity metric</li> <li>The difference can be larger or smaller in different parts of the dataset. For the best evaluation try to either run prediction in both modes on the whole evaluation dataset or at least make sure to get a representative sampling</li> <li>This notebook shows the results for semantic segmentation but the same applies to other tasks. For example, for classification Dice in the train/eval disparity metric can be replaced with accuracy, F1 score or your favorite metric</li> </ul>"},{"location":"train-eval-disparity/#i-have-traineval-mismatch-what-to-do","title":"I have train/eval mismatch - what to do?","text":"<p>If you established that the model performance degrades when you switch from <code>model.train()</code> to <code>model.eval()</code>, unfortunately, there's not much to do but to retrain the model. This problem appears because the training batches were too random and not representative of the overall dataset distribution.   </p> <p>If you are willing to retrain, there are multiple options:</p> <ul> <li> <p>Use larger batch size</p> <p>As we have seen in our experiment with different batch sizes, the larger the batch size, the more likely it is that the samples correctly represent the diversity of the dataset. Chances are you are already using the largest possible batch size but hey this is a great reason to get a cooler GPU.</p> </li> <li> <p>Downsample the data</p> <p>Old image analysis wisdom says: solve your problem at the minimal possible resolution. Downsampling the image makes effective patch size larger, meaning that the same amount of GPU memory can be used to sample more of the dataset. In my experience, downsampling microscopy data is rarely viable because the objects of interest (cell or nuclei boundaries, organelles, membranes) are already at the edge of what is possible to recognize at the available resolution. </p> </li> <li> <p>Sample only foreground patches or control the proportion of classes in a batch for classification</p> <p>Sampling only patches that contain foreground is an easy way to reduce variability of the patches and make patch feature distributions more stable. In tasks such as nuclei segmentation in light microscopy (bright objects on mostly dark background), this approach works perfectly. Of course, for electron microscopy it would not work: if I were to sample only the cell boundaries, there would be no patches coming from middle part of the cells. There are many features inside the cell that resemble the boundary, so if they were not present in the training patches, who knows what the network would predict there.</p> <p>I looked into a lot of publications which use U-Net for segmentation of microscopy or medical images and most of them had some kind of weighted patch sampling. I believe that it was a secret for making their training work (as opposed to whatever was claimed in the paper, such as a fancy loss or specialized augmentation). In the remaining cases it could be that the training data was cropped to contain only the region of interest in the first place.</p> </li> <li> <p><code>BatchRenorm</code></p> <p>If none of the above are possible, I suggest giving <code>Batch Renormalization</code> a try. <code>BatchRenorm</code> is a normalization layer that uses running mean and variance both during training and during inference. I managed to achieve quite good results with it both for electron and fluorescent microscopy images However, the training takes a bit longer.</p> </li> </ul>"},{"location":"train-eval-disparity/#adding-more-ground-truth-doesnt-solve-the-problem","title":"Adding more ground truth doesn't solve the problem","text":"<p>The usual explanation of the mismatch between <code>train</code> and <code>eval</code> mode is overfitting. In principle overfitting could be partially solved with adding more ground truth by achieving more representative training sample. Batch statistics instability prevents the network from effectively using the training data, so even performance on the training set is suboptimal. Wrong estimation of mean and variance of the feature maps prevents the network from making good predictions in eval mode even for the data from the training set. </p>"},{"location":"train-eval-disparity/#conclusion","title":"Conclusion","text":"<ul> <li> <p>Biological images often have high variability within one image and are much larger than GPU memory. Patches sampled in training can have completely different class distribution and even completely miss some classes due to general class imbalance and image content distribution.</p> </li> <li> <p>Especially for 3D data the batch size is very limited by the GPU memory. It is pretty normal to use batch size 1 or 2. Together with high diversity within images this causes batch statistics of feature maps to be estimated incorrectly. Running mean and variance do not correspond to the training mode batch statistics, leading to a puzzling low prediction quality when the model is applied to the new data. </p> </li> <li> <p>Of course, this tutorial shows an extreme case. The strength of the effect depends on the interplay between the data homogeneity, sampling strategy, patch size and batch size. Due to this a training pipeline that worked perfectly fine on one dataset can completely fail on another similar dataset - and it's really hard to say why unless we keep the normalization in mind. </p> </li> </ul> <p>Let's say we want to segment mitochondria in different datasets. In one case in the training image, mitochondria happened to be evenly distributed throughout the cell for biological reasons - then the batch statistics will be rather stable because it's likely that each patch hits an area with some mitochondria. In the other case large areas of the cell don't have mitochondria - the batch statistics might be way less stable and the model might perform much worse. It's very hard to debug because the images might seem similar in terms of resolution or contrast, why would the same training pipeline not work for both? </p> <ul> <li>Fortunately, it's very easy to check if train/eval disparity is a problem in a particular case. Just check if predictions in both modes on the same image are close enough. If there is a significant difference but you are not convinced, it's possible to check the feature maps and see directly if statistics are different.</li> </ul> <p>For examples of different modalities, architectures (Transformer-based networks suffer from this too!) and quantitative results check out my manuscript Tiling artifacts and trade-offs of feature normalization in the segmentation of large biological images.</p>"}]}